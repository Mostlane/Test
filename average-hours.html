export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    const headers = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, X-User",
      "Content-Type": "application/json"
    };

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers });
    }

    if (request.method !== "GET") {
      return new Response(JSON.stringify({ error: "Method not allowed" }), { status: 405, headers });
    }

    // ðŸ” Explicit allow-list
    const ALLOWED_USERS = new Set([
      "Jamie.Line",
      "Joe.Line",
      "Greg.Line"
    ]);

    // âœ… flexible compare (case/whitespace safe)
    const requestingUserRaw = request.headers.get("X-User") || "";
    const requestingUser = requestingUserRaw.trim();
    const allowCosts = Array.from(ALLOWED_USERS).some(u => u.toLowerCase() === requestingUser.toLowerCase());

    const startParam = url.searchParams.get("start");
    const endParam = url.searchParams.get("end");
    const metric = (url.searchParams.get("metric") || "onsite").toLowerCase();

    if (!startParam || !endParam) {
      return new Response(JSON.stringify({
        error: "Missing start or end date (YYYY-MM-DD)"
      }), { status: 400, headers });
    }

    const start = new Date(startParam + "T00:00:00");
    const end = new Date(endParam + "T00:00:00");

    if (isNaN(start) || isNaN(end) || start > end) {
      return new Response(JSON.stringify({ error: "Invalid date range" }), { status: 400, headers });
    }

    function fmt(d) {
      return d.toISOString().split("T")[0];
    }

    function minutes(t) {
      if (!t || t === "00:00") return null;
      const [h, m] = t.split(":").map(Number);
      if (!Number.isFinite(h) || !Number.isFinite(m)) return null;
      return h * 60 + m;
    }

    // ðŸ”’ Only load rates if user is allowed
    const rates = allowCosts
      ? (await env.RATES_KV.get("rates", { type: "json" }) || {})
      : {};

    // âœ… Travel sanity caps (prevents bogus 16h travel days poisoning stats)
    // Adjust if you genuinely have very long travel days.
    const MAX_TRAVEL_TOTAL_HOURS = 6; // total to+from (per day)
    const MAX_TRAVEL_LEG_HOURS = 4;   // either leg (to or from)

    const days = [];
    const cursor = new Date(start);

    while (cursor <= end) {
      days.push(fmt(cursor));
      cursor.setDate(cursor.getDate() + 1);
    }

    const map = {};

    // optional debug counts (won't break anything if ignored)
    let skippedTravelOutliers = 0;
    let skippedOnsiteOutliers = 0;

    for (const day of days) {
      const raw = await env.HOURS_KV.get(`hours:${day}`, { type: "json" });
      if (!Array.isArray(raw)) continue;

      for (const entry of raw) {
        const engineer = entry.engineer;
        if (!engineer) continue;

        // existing filters
        if (entry.excludeFromPay === true) continue;
        if (typeof entry.notes === "string" && entry.notes.toLowerCase().includes("holiday")) continue;

        let value = null;

        if (metric === "travel") {
          const to = Number(entry.travelToHours);
          const from = Number(entry.travelFromHours);

          // must be finite + non-negative
          if (!isFinite(to) || !isFinite(from) || to < 0 || from < 0) {
            skippedTravelOutliers++;
            continue;
          }

          // sanity caps
          if (to > MAX_TRAVEL_LEG_HOURS || from > MAX_TRAVEL_LEG_HOURS || (to + from) > MAX_TRAVEL_TOTAL_HOURS) {
            skippedTravelOutliers++;
            continue;
          }

          value = to + from;

        } else {
          // onsite time (arrive first -> leave last), with cross-midnight support + sanity cap
          const a = minutes(entry.arriveFirstSite);
          const l0 = minutes(entry.leaveLastSite);

          if (a == null || l0 == null) {
            skippedOnsiteOutliers++;
            continue;
          }

          let dur = l0 - a;

          // ðŸŒ™ cross-midnight support
          if (dur < 0) dur += 24 * 60;

          // sanity cap (ignore impossible)
          if (dur <= 0 || dur > 14 * 60) {
            skippedOnsiteOutliers++;
            continue;
          }

          value = dur / 60;
        }

        if (value == null) continue;

        map[engineer] ??= {};
        const prev = map[engineer][day];

        // keep latest submission for the day
        if (!prev || new Date(entry.submittedAt) > new Date(prev.submittedAt)) {
          map[engineer][day] = {
            submittedAt: entry.submittedAt,
            hours: value
          };
        }
      }
    }

    const engineers = [];

    for (const [engineer, daysMap] of Object.entries(map)) {
      const values = Object.values(daysMap).map(d => d.hours);
      if (!values.length) continue;

      const sum = values.reduce((a, b) => a + b, 0);
      const average = +(sum / values.length).toFixed(2);

      const row = {
        engineer,
        days: values.length,
        average,
        min: +Math.min(...values).toFixed(2),
        max: +Math.max(...values).toFixed(2)
      };

      // ðŸ’· Cost calculation (ONLY for allowed users)
      if (allowCosts) {
        const r = rates[engineer] || {};
        const rate =
          metric === "travel"
            ? Number(r.travelRate)
            : Number(r.onsiteRate);

        if (isFinite(rate)) {
          row.costPerDay = +(rate * average).toFixed(2);
          row.periodCost = +(row.costPerDay * row.days).toFixed(2);
        }
      }

      engineers.push(row);
    }

    engineers.sort((a, b) => b.average - a.average);

    return new Response(JSON.stringify({
      metric,
      start: startParam,
      end: endParam,
      costsEnabled: allowCosts,
      generatedAt: new Date().toISOString(),
      engineers,

      // optional debug fields (safe if ignored by HTML)
      skipped: {
        travelOutliers: skippedTravelOutliers,
        onsiteOutliers: skippedOnsiteOutliers
      }
    }), { headers });
  }
};
