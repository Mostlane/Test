<!doctype html>
<html lang="en">
<head>
  <script src="auth.js"></script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mostlane ‚Ä¢ Advanced Hours Dashboard v3 (Live, Fixed)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --panelEdge:#0b1222; --text:#e5e7eb; --muted:#9ca3af;
      --ok:#10b981; --warn:#f59e0b; --bad:#ef4444;
      --blue:#3b82f6; --indigo:#6366f1; --cyan:#22d3ee; --yellow:#facc15; --teal:#14b8a6;
    }
    body{margin:0;background:linear-gradient(180deg,#0b132a,#0a0f1f);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{display:grid;grid-template-columns: 1fr 320px; gap:16px; padding:16px}
    .area{display:grid; grid-template-columns: repeat(2,minmax(0,1fr)); gap:16px}
    .panel{background:var(--panel); border:1px solid #1f2937; border-radius:10px; padding:14px; box-shadow:inset 0 0 0 1px var(--panelEdge), 0 6px 16px rgba(0,0,0,.35)}
    .title{font-weight:600; font-size:14px; color:var(--muted); margin-bottom:8px}
    .kpiGrid{display:grid; grid-template-columns: repeat(4,1fr); gap:16px; margin-bottom:16px}
    .kpi .num{font-size:28px; font-weight:800}
    .kpi .sub{color:var(--muted); font-size:12px}
    .leaderboard .row{display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px dashed #334155}
    .leaderboard .row:last-child{border-bottom:none}
    .pill{display:inline-block; font-size:11px; border-radius:999px; padding:2px 8px}
    .ok{background:#04281e;color:#34d399} .warn{background:#422d14;color:#fbbf24} .bad{background:#3b0e0e;color:#fca5a5}
    .topbar{grid-column:1/3; display:flex; justify-content:space-between; align-items:center; margin-bottom:4px}
    .btn{appearance:none; border:1px solid #334155; background:#0b132a; color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; text-decoration:none}
    .highlight{font-size:18px;font-weight:700;color:var(--blue)}
    .muted{color:var(--muted)}
    .hint{font-size:12px;color:var(--muted);margin-top:4px}
    canvas{max-width:100%}
    @media(max-width:1100px){ .wrap{grid-template-columns:1fr} .area{grid-template-columns:1fr} .kpiGrid{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="area">
      <div class="topbar" style="grid-column:1/2">
        <div>
          <div style="font-weight:700;font-size:20px">Advanced Hours Dashboard</div>
          <div class="hint">Week view based on Cloudflare Worker JSON</div>
          <div style="margin-top:6px">
            üèÜ Top Engineer ‚Äì This Week: <span class="highlight" id="topWeek">‚Äì</span><br>
            üèÜ Top Engineer ‚Äì Last 6 Weeks: <span class="highlight" id="topHist">‚Äì</span>
          </div>
        </div>
      </div>
      <div class="topbar" style="grid-column:2/3;justify-content:flex-end;gap:8px">
        <a href="hours-dashboard-simple-v2.html" class="btn">Simple View</a>
      </div>

      <!-- KPI TILES -->
      <div class="panel kpiGrid" style="grid-column:1/3">
        <div class="panel kpi"><div class="num" id="kpi-engineers">‚Äì</div><div class="sub">Engineers (active this week)</div></div>
        <div class="panel kpi"><div class="num" id="kpi-worked">‚Äì</div><div class="sub">Hours worked so far (team)</div></div>
        <div class="panel kpi"><div class="num" id="kpi-pred">‚Äì</div><div class="sub">Predicted total this week (team, Mon‚ÄìFri)</div></div>
        <div class="panel kpi"><div class="num" id="kpi-remaining">‚Äì</div><div class="sub">Team hours remaining vs cap</div></div>
      </div>

      <!-- Charts -->
      <div class="panel"><div class="title">Team progress (Worked vs Cap)</div><canvas id="progressTeam" height="100"></canvas></div>
      <div class="panel"><div class="title">Avg engineer vs 40h cap</div><canvas id="progressAvg" height="100"></canvas></div>
      <div class="panel"><div class="title">Risk distribution</div><canvas id="donutRisk" height="120"></canvas></div>
      <div class="panel"><div class="title">By engineer (worked, predicted & cap)</div><canvas id="stackedByEngineer" height="140"></canvas></div>
      <div class="panel" style="grid-column:1/3"><div class="title">Hours by day (current week)</div><canvas id="byDay" height="140"></canvas></div>
    </div>

    <!-- Right Column Leaderboards -->
    <div class="panel leaderboard" style="max-height:calc(100vh - 32px);overflow:auto">
      <div class="title">Leaderboards ‚Ä¢ This Week</div>
      <div id="lb-week"></div>
      <div class="title" style="margin-top:12px">Leaderboards ‚Ä¢ Last 6 Weeks</div>
      <div id="lb-hist"></div>
    </div>
  </div>

<script>
/** ======= CONFIG ======= **/
const HOURS_URL = "https://odd-water-f78a.jamie-def.workers.dev/Hours";
const CAP_PER_ENGINEER = 40;
const WEEKDAYS_TARGET = 5; // projection uses Monday‚ÄìFriday only

/** ======= HELPERS ======= **/
const $ = (id) => document.getElementById(id);
const toFloat = (v) => v==null ? 0 : parseFloat(v)||0;

function parseISODate(s){
  // force UTC noon to avoid TZ edge cases
  const d = new Date(s + "T12:00:00Z");
  return isNaN(d) ? null : d;
}
function uniq(arr){ return [...new Set(arr)]; }
function sum(arr){ return arr.reduce((a,b)=>a+toFloat(b),0); }
function fmtHours(n){ return (Math.round(n*100)/100).toFixed(2) + "h"; }
function weekLabel(weekKey){
  // weekKey is Sunday ISO; label as "w/c Mon DD MMM"
  const sun = parseISODate(weekKey);
  if(!sun) return weekKey;
  const mon = new Date(sun); mon.setUTCDate(sun.getUTCDate()+1);
  return "w/c " + mon.toLocaleDateString("en-GB",{day:"2-digit", month:"short"});
}

/** ======= FETCH & SHAPE DATA ======= **/
async function loadHours(){
  const res = await fetch(HOURS_URL + "?t=" + Date.now(), { cache: "no-store" });
  if(!res.ok) throw new Error("Failed to load Hours JSON");
  return await res.json();
}

/**
 * Flatten Worker store to an array of entries with weekKey/date/engineer etc.
 * Input shape: { "YYYY-MM-DD":[ {entry}, {entry}, ... ], ... }
 * We also dedupe by (engineer|date) keeping the latest submittedAt.
 */
function flattenAndDedupe(json){
  const all = [];
  for(const k of Object.keys(json||{})){
    const arr = Array.isArray(json[k]) ? json[k] : [];
    for(const e of arr){
      if(e && typeof e === "object" && e.date && e.engineer){
        all.push(e);
      }
    }
  }
  // Dedupe by engineer+date, keep latest submittedAt
  const map = new Map();
  for(const e of all){
    const key = (e.engineer||"").trim() + "||" + e.date;
    const prev = map.get(key);
    if(!prev){ map.set(key, e); continue; }
    const pt = prev.submittedAt ? Date.parse(prev.submittedAt) : 0;
    const ct = e.submittedAt ? Date.parse(e.submittedAt) : 0;
    if(ct >= pt) map.set(key, e);
  }
  return Array.from(map.values());
}

/**
 * Use entry.weekKey when present; fallback: derive Sunday from date.
 * Return sorted ASC, valid YYYY-MM-DD only.
 */
function weekKeysFromEntries(entries){
  const keys = new Set();
  for(const e of entries){
    const wk = e.weekKey || deriveWeekKey(e.date);
    if(wk) keys.add(wk);
  }
  const sorted = [...keys].filter(k => /^\d{4}-\d{2}-\d{2}$/.test(k)).sort();
  return sorted;
}

function deriveWeekKey(dateStr){
  const d = parseISODate(dateStr);
  if(!d) return null;
  const sun = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
  // move to Sunday of that week (0=Sunday)
  const day = sun.getUTCDay(); // 0..6
  sun.setUTCDate(sun.getUTCDate() - day);
  return sun.toISOString().split("T")[0];
}

/** ======= COMPUTE METRICS ======= **/
/**
 * Build per-engineer aggregates for a given weekKey (Mon‚ÄìFri prediction only).
 * Returns map: name -> { name, worked, overtime, travel, predicted, cap, vanCheck }
 */
function aggregateWeek(entries, weekKey){
  const cur = entries.filter(e => (e.weekKey || deriveWeekKey(e.date)) === weekKey);

  const byEng = new Map();
  for(const e of cur){
    const name = (e.engineer||"").trim();
    if(!name) continue;

    if(!byEng.has(name)){
      byEng.set(name, {
        name,
        worked: 0,            // total paid hours (full week actual)
        overtime: 0,          // total OT (full week actual)
        travel: 0,            // total travel (full week actual)
        weekdayWorked: 0,     // Mon‚ÄìFri paid hours (for avg + prediction)
        weekdayDays: 0,       // Mon‚ÄìFri unique days worked
        predicted: 0,
        cap: CAP_PER_ENGINEER,
        vanCheck: null        // "Yes" / "No" / null
      });
    }
    const rec = byEng.get(name);

    // safe numeric parsing
    const total = toFloat(e.totalHours);
    const overtime = toFloat(e.overtimeHours);
    const travel = toFloat(e.totalTravelHours);

    rec.worked += total;
    rec.overtime += overtime;
    rec.travel += travel;

    // Mon‚ÄìFri counting for prediction
    const d = parseISODate(e.date);
    if(d){
      const dow = d.getUTCDay(); // 0 Sun .. 6 Sat
      if(dow >= 1 && dow <= 5){
        rec.weekdayWorked += total;
        rec.weekdayDays += 1;
      }
    }

    // Van check mapping (support both fields)
    const vc = ((e.vanCheckWeekStatus || e.vanCheck || "") + "").trim();
    if(vc === "Failed" || vc === "No"){ rec.vanCheck = "No"; }
    else if(vc === "Passed" || vc === "Yes"){
      if(rec.vanCheck !== "No") rec.vanCheck = "Yes";
    }
  }

  // Finalise predicted using avg weekday hours so far √ó 5 (Mon‚ÄìFri)
  for(const rec of byEng.values()){
    const daysWorked = rec.weekdayDays || 0;
    const avgPerDay = daysWorked ? (rec.weekdayWorked / daysWorked) : 0;
    rec.predicted = avgPerDay * WEEKDAYS_TARGET;
  }
  return byEng;
}

/**
 * Build 6-week history per engineer:
 * history[name] = [{weekKey, worked, overtime, travel, vanCheck}, ...] (sorted ascending)
 */
function buildHistory(entries, weekKeys, limit=6){
  const last = weekKeys.slice(-limit);
  const out = new Map();
  for(const wk of last){
    const agg = aggregateWeek(entries, wk);
    agg.forEach((rec, name)=>{
      if(!out.has(name)) out.set(name, []);
      out.get(name).push({
        weekKey: wk,
        worked: rec.worked,
        overtime: rec.overtime,
        travel: rec.travel,
        vanCheck: rec.vanCheck
      });
    });
  }
  return { weeks:last, history:out };
}

/** ======= SCORING ======= **/
function weeklyScore(rec){
  // score using worked, overtime, travel efficiency, van check, closeness to cap
  const worked = rec.worked;
  const overtime = rec.overtime;
  const travel = rec.travel;
  const eff = worked ? Math.max(0, (worked - travel) / worked) : 1;

  let s = 100;
  s -= 2 * Math.max(0, overtime);               // penalise OT
  if(eff < 0.75) s -= 15; else if(eff < 0.85) s -= 7; else if(eff > 0.92) s += 5; // efficiency
  if(rec.vanCheck === "No") s -= 20; else if(rec.vanCheck === "Yes") s += 2;      // van checks
  const diff = Math.abs(CAP_PER_ENGINEER - Math.min(rec.predicted, 1e6));         // closeness to cap
  if(diff <= 4) s += 4;
  return Math.max(0, Math.min(100, s));
}

function historicScore(historyArr){
  if(!historyArr || !historyArr.length) return 0;
  const workedAvg = sum(historyArr.map(h=>h.worked))/historyArr.length;
  const otAvg = sum(historyArr.map(h=>h.overtime))/historyArr.length;
  const travelAvg = sum(historyArr.map(h=>h.travel))/historyArr.length;
  const eff = workedAvg ? Math.max(0,(workedAvg - travelAvg)/workedAvg) : 1;
  const checksGood = historyArr.filter(h=>h.vanCheck==="Yes").length / historyArr.length;

  let s = 100;
  const diff = Math.abs(CAP_PER_ENGINEER - workedAvg);
  if(diff <= 2) s += 5; else if(diff > 8) s -= 5;
  s -= 1.5 * otAvg;                   // sustained OT penalty
  if(eff < 0.8) s -= 10; else if(eff > 0.92) s += 5;
  s += 10 * (checksGood - 0.8);       // van checks trend
  return Math.max(0, Math.min(100, s));
}

/** ======= RENDER ======= **/
function pill(val,type){return `<span class="pill ${type}">${val}</span>`}
function addBoard(container,title,rows){
  const div=document.createElement('div');
  div.innerHTML=`<div style="font-weight:600;margin-top:10px">${title}</div>`+rows.map(r=>`<div class='row'>${r}</div>`).join("");
  container.appendChild(div);
}
function colorFor(pred,cap){
  if(pred>cap) return "#ef4444"; // bad
  if(pred>cap*0.9) return "#f59e0b"; // warn
  return "#10b981"; // ok
}

/** ======= MAIN ======= **/
(async function init(){
  try{
    const json = await loadHours();
    const entries = flattenAndDedupe(json);
    if(!entries.length){
      ["topWeek","topHist","kpi-engineers","kpi-worked","kpi-pred","kpi-remaining"].forEach(id=>$(id).textContent="‚Äì");
      return;
    }

    const weeks = weekKeysFromEntries(entries);
    if(!weeks.length){
      ["topWeek","topHist","kpi-engineers","kpi-worked","kpi-pred","kpi-remaining"].forEach(id=>$(id).textContent="‚Äì");
      return;
    }
    const currentWeekKey = weeks[weeks.length-1]; // latest available week in JSON

    const curAgg = aggregateWeek(entries, currentWeekKey);
    const engineers = [...curAgg.values()].sort((a,b)=>a.name.localeCompare(b.name));

    // History (last 6 weeks) for trends/leaderboards
    const { weeks:histWeeks, history } = buildHistory(entries, weeks, 6);

    // KPIs
    const teamWorked = sum(engineers.map(e=>e.worked));
    const teamPred = sum(engineers.map(e=>e.predicted));
    const teamCap = engineers.length * CAP_PER_ENGINEER;

    $("kpi-engineers").textContent = String(engineers.length);
    $("kpi-worked").textContent = fmtHours(teamWorked);
    $("kpi-pred").textContent = fmtHours(teamPred);
    $("kpi-remaining").textContent = fmtHours(Math.max(0,teamCap - teamPred));

    // Top engineer (week & historic)
    const weekRank = engineers
      .map(e=>({ name:e.name, score: weeklyScore(e)}))
      .sort((a,b)=>b.score-a.score);
    $("topWeek").textContent = weekRank.length? `${weekRank[0].name} (${weekRank[0].score.toFixed(0)})` : "‚Äì";

    const histRank = [...history.entries()]
      .map(([name,arr])=>({ name, score: historicScore(arr) }))
      .sort((a,b)=>b.score-a.score);
    $("topHist").textContent = histRank.length? `${histRank[0].name} (${histRank[0].score.toFixed(0)})` : "‚Äì";

    // Leaderboards (this week)
    const lbw = $("lb-week"); lbw.innerHTML="";
    addBoard(lbw,"Highest Hours (Predicted)",
      [...engineers].sort((a,b)=>b.predicted-a.predicted).map(e=>`${e.name} ${e.predicted.toFixed(2)}h`));
    addBoard(lbw,"Overtime (This Week)",
      [...engineers].sort((a,b)=>b.overtime-a.overtime).map(e=>`${e.name} ${e.overtime.toFixed(2)}h`));
    addBoard(lbw,"Efficiency (Worked‚ÄìTravel / Worked)",
      [...engineers].sort((a,b)=>((b.worked-b.travel)/Math.max(0.1,b.worked)) - ((a.worked-a.travel)/Math.max(0.1,a.worked)))
      .map(e=>{
        const eff = e.worked ? 100*(e.worked-e.travel)/e.worked : 100;
        return `${e.name} ${eff.toFixed(0)}%`;
      })
    );
    addBoard(lbw,"Van Checks",
      engineers.map(e=>`${e.name} ${e.vanCheck==="Yes"?"‚úÖ":"‚ùå"}`));

    // Leaderboards (6-week trends)
    const lbh = $("lb-hist"); lbh.innerHTML="";
    // Avg Weekly Hours
    addBoard(lbh,"Avg Weekly Hours",
      [...history.entries()].sort((a,b)=>{
        const avga = sum(a[1].map(x=>x.worked))/a[1].length;
        const avgb = sum(b[1].map(x=>x.worked))/b[1].length;
        return avgb-avga;
      }).map(([name,arr])=>{
        const avg = sum(arr.map(x=>x.worked))/arr.length;
        return `${name} ${avg.toFixed(1)}h`;
      })
    );
    // Overtime (6 weeks sum)
    addBoard(lbh,"Overtime (6 wks)",
      [...history.entries()].sort((a,b)=>{
        const sa = sum(a[1].map(x=>x.overtime));
        const sb = sum(b[1].map(x=>x.overtime));
        return sb-sa;
      }).map(([name,arr])=>{
        const tot = sum(arr.map(x=>x.overtime));
        return `${name} ${tot.toFixed(1)}h`;
      })
    );
    // Efficiency Avg
    addBoard(lbh,"Efficiency Avg",
      [...history.entries()].sort((a,b)=>{
        const effA = (()=>{ const w=sum(a[1].map(x=>x.worked)), t=sum(a[1].map(x=>x.travel)); return w? (w-t)/w : 1; })();
        const effB = (()=>{ const w=sum(b[1].map(x=>x.worked)), t=sum(b[1].map(x=>x.travel)); return w? (w-t)/w : 1; })();
        return effB-effA;
      }).map(([name,arr])=>{
        const w=sum(arr.map(x=>x.worked)), t=sum(arr.map(x=>x.travel));
        const eff = w? 100*(w-t)/w : 100;
        return `${name} ${eff.toFixed(0)}%`;
      })
    );
    // Van Checks Avg
    addBoard(lbh,"Van Checks Avg",
      [...history.entries()].sort((a,b)=>{
        const ra = a[1].filter(x=>x.vanCheck==="Yes").length / a[1].length;
        const rb = b[1].filter(x=>x.vanCheck==="Yes").length / b[1].length;
        return rb-ra;
      }).map(([name,arr])=>{
        const r = 100 * (arr.filter(x=>x.vanCheck==="Yes").length/arr.length);
        return `${name} ${r.toFixed(0)}%`;
      })
    );

    /** ===== Charts ===== **/
    // Team progress (Worked vs Team Cap) ‚Äî label with current week
    const labelWeek = weekLabel(currentWeekKey);
    new Chart($("progressTeam").getContext("2d"),{
      type:"bar",
      data:{ labels:[labelWeek],
        datasets:[
          { label:"Worked (so far)", data:[teamWorked], backgroundColor:"#2563eb" },
          { label:"Team Cap", data:[teamCap], backgroundColor:"#334155" }
        ]
      },
      options:{ plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true } } }
    });

    // Avg engineer vs 40h cap (predicted)
    const avgPred = engineers.length ? teamPred/engineers.length : 0;
    new Chart($("progressAvg").getContext("2d"),{
      type:"bar",
      data:{ labels:["Avg engineer (predicted)"],
        datasets:[
          { label:"Predicted (Mon‚ÄìFri)", data:[avgPred], backgroundColor:colorFor(avgPred,CAP_PER_ENGINEER) },
          { label:"Cap", data:[CAP_PER_ENGINEER], backgroundColor:"#334155" }
        ]
      },
      options:{ plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true } } }
    });

    // Risk donut (based on predicted vs cap)
    const ok = engineers.filter(e=>e.predicted<=0.9*e.cap).length;
    const warn = engineers.filter(e=>e.predicted>0.9*e.cap && e.predicted<=e.cap).length;
    const bad = engineers.filter(e=>e.predicted>e.cap).length;
    new Chart($("donutRisk").getContext("2d"),{
      type:"doughnut",
      data:{ labels:["On track","Close","Over"],
        datasets:[{ data:[ok,warn,bad], backgroundColor:["#10b981","#f59e0b","#ef4444"] }]
      },
      options:{ plugins:{ legend:{ position:"bottom" } }, cutout:"60%" }
    });

    // By engineer (worked bars + cap line + predicted dots)
    new Chart($("stackedByEngineer").getContext("2d"),{
      type:"bar",
      data:{
        labels: engineers.map(e=>e.name),
        datasets:[
          { label:"Worked (so far)", data: engineers.map(e=>+e.worked.toFixed(2)), backgroundColor: engineers.map(e=>colorFor(e.predicted,e.cap)) },
          { type:"line", label:"Cap (40h)", data: engineers.map(()=>CAP_PER_ENGINEER), borderColor:"#3b82f6", borderWidth:2, pointRadius:0 },
          { type:"line", label:"Predicted (Mon‚ÄìFri)", data: engineers.map(e=>+e.predicted.toFixed(2)), borderColor:"#f59e0b", borderWidth:2, pointRadius:3 }
        ]
      },
      options:{ plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true } } }
    });

    // Hours by day (current week): team totals per weekday (Mon..Fri)
    const curEntries = entries.filter(e => (e.weekKey||deriveWeekKey(e.date)) === currentWeekKey);
    const byDayTotals = {Mon:0,Tue:0,Wed:0,Thu:0,Fri:0};
    for(const e of curEntries){
      const d = parseISODate(e.date); if(!d) continue;
      const dow = d.getUTCDay();
      if(dow===1) byDayTotals.Mon += toFloat(e.totalHours);
      if(dow===2) byDayTotals.Tue += toFloat(e.totalHours);
      if(dow===3) byDayTotals.Wed += toFloat(e.totalHours);
      if(dow===4) byDayTotals.Thu += toFloat(e.totalHours);
      if(dow===5) byDayTotals.Fri += toFloat(e.totalHours);
    }
    new Chart($("byDay").getContext("2d"),{
      type:"bar",
      data:{ labels:["Mon","Tue","Wed","Thu","Fri"],
        datasets:[{ label:"Team hours", data:[byDayTotals.Mon,byDayTotals.Tue,byDayTotals.Wed,byDayTotals.Thu,byDayTotals.Fri], backgroundColor: "#14b8a6" } ]
      },
      options:{ plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true } } }
    });

  }catch(err){
    console.error(err);
    ["topWeek","topHist","kpi-engineers","kpi-worked","kpi-pred","kpi-remaining"].forEach(id=>$(id).textContent="‚Äì");
    alert("Failed to load hours: " + err.message);
  }
})();
</script>
</body>
</html>
