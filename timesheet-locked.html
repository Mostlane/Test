<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>My Timesheet ‚Äì Mostlane</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>

<!-- PDF LIBRARY -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

<style>
:root{
  --ml-blue:#003366;
  --ml-accent:#1a73e8;
  --ml-ink:#27313a;
  --ml-bg:#e6e8eb;
  --muted:#6b7280;
  --border:#e5e7eb;
  --ok:#15803d;
  --warn:#b91c1c;
}

html,body{margin:0;padding:0;width:100%;overflow-x:hidden;}

body{
  font-family:"Segoe UI",system-ui,Roboto,Arial,sans-serif;
  background:var(--ml-bg) url('Mostlane_Embossed.png') no-repeat center center fixed;
  background-size:180% auto;
  padding:16px;
  color:var(--ml-ink);
}

.shell{
  max-width:900px;
  margin:0 auto;
  background:rgba(255,255,255,0.94);
  border-radius:16px;
  box-shadow:0 12px 28px rgba(0,0,0,0.12);
  overflow:hidden;
}

header{
  padding:18px;
  text-align:center;
}

header h1{
  margin:0 0 12px 0;
  color:var(--ml-blue);
}

header a, header button{
  display:block;
  width:100%;
  margin-top:8px;
  padding:10px;
  border-radius:10px;
  font-weight:600;
  border:none;
}

header a{
  background:var(--ml-accent);
  color:#fff;
  text-decoration:none;
}

header button{
  background:#003366;
  color:#fff;
  cursor:pointer;
}

.content{padding:18px;}

.controls{
  display:grid;
  grid-template-columns:1fr;
  gap:10px;
  margin-bottom:20px;
}

.controls button,.controls .pill{
  padding:10px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#f8fafc;
  font-weight:600;
  text-align:center;
}

.day-group{margin-bottom:22px;}

.day-header{
  font-weight:700;
  color:#111827;
  border-bottom:2px solid #e5e7eb;
  padding-bottom:6px;
  margin-bottom:12px;
}

.session-card{
  background:#fff;
  border-radius:14px;
  padding:14px 16px;
  margin-bottom:12px;
  border:1px solid #eef2f7;
  box-shadow:
    0 1px 2px rgba(0,0,0,0.04),
    0 6px 16px rgba(0,0,0,0.06);
}

.session-time{
  font-size:18px;
  font-weight:700;
  color:var(--ml-blue);
}

.session-hours{
  margin-top:6px;
  font-size:13px;
  font-weight:600;
}

.session-hours span{margin-right:14px;}

.location{
  margin-top:8px;
  font-size:13px;
  display:flex;
  align-items:center;
  gap:6px;
}

.location a{
  color:var(--ml-accent);
  text-decoration:none;
  font-weight:600;
}

.verified{color:var(--ok);font-weight:700;}
.unknown{color:var(--warn);}

.summary{
  margin-top:20px;
  display:grid;
  gap:10px;
}

.summary div{
  padding:10px;
  border-radius:12px;
  background:#f8fafc;
  border:1px solid var(--border);
  font-weight:600;
  display:flex;
  justify-content:space-between;
}

.note{
  margin-top:12px;
  font-size:13px;
  color:#6b7280;
}
</style>
</head>

<body>
<div class="shell" id="pdfRoot">
<header>
  <h1>My Weekly Timesheet</h1>
  <a href="main.html">Main Menu</a>
  <button id="exportBtn">üìÑ Export PDF</button>
</header>

<div class="content">
<div class="controls">
  <button id="prevWeek">‚óÄ Previous Week</button>
  <div class="pill">Week Commencing: <span id="weekLabel">‚Äî</span></div>
  <button id="nextWeek">Next Week ‚ñ∂</button>
  <div class="pill">Engineer: <span id="engineerName">‚Äî</span></div>
</div>

<div id="sessions"></div>

<div class="summary">
  <div><span>Standard</span><span id="sumStd">0.00 h</span></div>
  <div><span>Overtime</span><span id="sumOT">0.00 h</span></div>
  <div><span>Total</span><span id="sumTotal">0.00 h</span></div>
</div>

<div class="note">
  Sessions are calculated from <b>check-in ‚Üí check-out</b>.
</div>

<div id="status" class="note"></div>
</div>
</div>

<script>
function ordinal(n){
  const s=["th","st","nd","rd"],v=n%100;
  return n+(s[(v-20)%10]||s[v]||s[0]);
}
function friendlyDate(d){
  return d.toLocaleDateString("en-GB",{weekday:"long",month:"short"})+
         " "+ordinal(d.getDate());
}
function time(d){return d.toISOString().slice(11,16);}
function startOfWeek(d){
  d=new Date(d);const day=d.getDay()||7;
  d.setDate(d.getDate()-day+1);d.setHours(0,0,0,0);return d;
}
function endOfWeek(d){
  d=new Date(d);d.setDate(d.getDate()+6);d.setHours(23,59,59,999);return d;
}
function hours(a,b){return (b-a)/36e5;}

const WORKER="https://ckeck-in-out.jamie-def.workers.dev";
const user=sessionStorage.getItem("mostlaneUser")||sessionStorage.getItem("mostlaneUsername");

const weekLabel=document.getElementById("weekLabel");
const engineerName=document.getElementById("engineerName");
const sessionsEl=document.getElementById("sessions");
const sumStd=document.getElementById("sumStd");
const sumOT=document.getElementById("sumOT");
const sumTotal=document.getElementById("sumTotal");
const statusEl=document.getElementById("status");

let currentWeek=startOfWeek(new Date());
engineerName.textContent=user||"‚Äî";

/* ===================== NEW (DO NOT REMOVE EXISTING LOGIC) ===================== */
/* Fix: some workers return {events:[...]} not a raw array; this keeps your page working */
function normaliseEventsPayload(payload){
  if (Array.isArray(payload)) return payload;
  if (payload && Array.isArray(payload.events)) return payload.events;
  if (payload && Array.isArray(payload.data)) return payload.data;
  if (payload && Array.isArray(payload.items)) return payload.items;
  if (payload && Array.isArray(payload.result)) return payload.result;
  if (payload && typeof payload==="object"){
    // last-resort: find first array value in object
    for(const k of Object.keys(payload)){
      if (Array.isArray(payload[k])) return payload[k];
      if (payload[k] && Array.isArray(payload[k].events)) return payload[k].events;
    }
  }
  return [];
}

/* Sites + travel time lookup (from your KV ‚ÄúSite Manager‚Äù worker) */
const SITES_WORKER="https://mostlane-sites.jamie-def.workers.dev";
let __ALL_SITES = null;

function toRad(x){return x*Math.PI/180;}
function haversineMeters(lat1, lon1, lat2, lon2){
  const R=6371000;
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
function getCoords(e){
  // your existing events use lat/lon
  if (typeof e.lat==="number" && typeof e.lon==="number") return {lat:e.lat, lon:e.lon};
  if (typeof e.lat==="string" && typeof e.lon==="string"){
    const la=parseFloat(e.lat), lo=parseFloat(e.lon);
    if(!isNaN(la)&&!isNaN(lo)) return {lat:la, lon:lo};
  }
  // sometimes logs use location_coords
  if (e.location_coords){
    if (typeof e.location_coords==="string" && e.location_coords.includes(",")){
      const parts=e.location_coords.split(",").map(s=>s.trim());
      const la=parseFloat(parts[0]), lo=parseFloat(parts[1]);
      if(!isNaN(la)&&!isNaN(lo)) return {lat:la, lon:lo};
    }
    if (Array.isArray(e.location_coords) && e.location_coords.length>=2){
      const la=parseFloat(e.location_coords[0]), lo=parseFloat(e.location_coords[1]);
      if(!isNaN(la)&&!isNaN(lo)) return {lat:la, lon:lo};
    }
    if (typeof e.location_coords==="object"){
      const la=parseFloat(e.location_coords.lat), lo=parseFloat(e.location_coords.lon ?? e.location_coords.lng);
      if(!isNaN(la)&&!isNaN(lo)) return {lat:la, lon:lo};
    }
  }
  return null;
}
async function loadSitesOnce(){
  if (__ALL_SITES) return __ALL_SITES;
  try{
    const r=await fetch(`${SITES_WORKER}/get-sites?category=all`, {cache:"no-store"});
    const j=await r.json();
    const arr = Array.isArray(j) ? j : (Array.isArray(j.sites)?j.sites:(Array.isArray(j.data)?j.data:[]));
    __ALL_SITES = (arr||[]).filter(s=>s && s.lat!=null && s.lon!=null);
  }catch(e){
    console.warn("Sites load failed", e);
    __ALL_SITES = [];
  }
  return __ALL_SITES;
}
function matchNearestSite(coords, maxMeters=500){
  if (!coords || !__ALL_SITES || !__ALL_SITES.length) return null;
  let best=null, bestM=Infinity;
  for(const s of __ALL_SITES){
    const la=parseFloat(s.lat), lo=parseFloat(s.lon);
    if(isNaN(la)||isNaN(lo)) continue;
    const m=haversineMeters(coords.lat, coords.lon, la, lo);
    if(m<bestM){bestM=m; best=s;}
  }
  if(best && bestM<=maxMeters) return best;
  return null;
}
function minsToHours(mins){
  const m=parseInt(mins,10);
  if(isNaN(m) || m<=0) return 0;
  return m/60;
}
/* ===================== END NEW ===================== */

async function loadWeek(){
  if(!user){statusEl.textContent="Not logged in.";return;}

  weekLabel.textContent=friendlyDate(currentWeek);
  sessionsEl.innerHTML="";
  statusEl.textContent="Loading‚Ä¶";

  const res=await fetch(`${WORKER}/events?user=${encodeURIComponent(user)}`);
  const allRaw=await res.json();

  /* ===================== NEW (keeps your existing logic intact) ===================== */
  const all = normaliseEventsPayload(allRaw); // critical: prevents ‚Äúshows nothing‚Äù
  await loadSitesOnce();
  /* ===================== END NEW ===================== */

  const weekEvents=all.filter(e=>{
    const d=new Date(e.datetime);
    return d>=currentWeek && d<=endOfWeek(currentWeek);
  });

  const byDay={};
  weekEvents.forEach(e=>{
    const d=new Date(e.datetime);
    const k=d.toISOString().slice(0,10);
    (byDay[k]??=[]).push({...e,d});
  });

  let total=0,std=0,ot=0;

  Object.keys(byDay).sort().forEach(dayKey=>{
    const list=byDay[dayKey].sort((a,b)=>a.d-b.d);
    const group=document.createElement("div");
    group.className="day-group";
    group.innerHTML=`<div class="day-header">${friendlyDate(list[0].d)}</div>`;

    let remainingStd=8;

    for(let i=0;i<list.length-1;i++){
      if(list[i].type==="checkin" && list[i+1].type==="checkout"){
        const h=hours(list[i].d,list[i+1].d);
        const s=Math.min(h,remainingStd);
        const o=Math.max(h-s,0);
        remainingStd-=s;

        total+=h;std+=s;ot+=o;

        /* ===================== NEW (map link stays working if coords missing) ===================== */
        const coordsForMap = getCoords(list[i]);
        const mapURL = coordsForMap
          ? `https://www.google.com/maps?q=${coordsForMap.lat},${coordsForMap.lon}`
          : `https://www.google.com/maps`;
        /* ===================== END NEW ===================== */

        let locationHTML=list[i].matchedSite
          ? `üìç ${list[i].matchedSite.siteName} <span class="verified">‚úî Verified</span>`
          : list[i].nearestSite
            ? `üìç Near ${list[i].nearestSite.siteName}`
            : `üìç <span class="unknown">Unknown location</span>`;

        group.innerHTML+=`
          <div class="session-card">
            <div class="session-time">${time(list[i].d)} ‚Üí ${time(list[i+1].d)}</div>
            <div class="session-hours">
              <span>Total ${h.toFixed(2)}</span>
              <span>Std ${s.toFixed(2)}</span>
              <span>OT ${o.toFixed(2)}</span>
            </div>
            <div class="location">${locationHTML}</div>
            <div class="location"><a href="${mapURL}" target="_blank">View on map</a></div>
          </div>`;
      }
    }

    /* ===================== NEW TRAVEL LOGIC (ONLY ADDED, NOTHING REMOVED) ===================== */
    // Use FIRST check-in and LAST check-out of the day.
    // If location matches a known site (<= 500m), add travelTimeFromHQMinutes for each end.
    let firstIn=null, lastOut=null;
    for(let i=0;i<list.length;i++){
      if(list[i].type==="checkin"){ firstIn=list[i]; break; }
    }
    for(let i=list.length-1;i>=0;i--){
      if(list[i].type==="checkout"){ lastOut=list[i]; break; }
    }

    // Only attempt if we have both ends
    if(firstIn && lastOut){
      const startSite = matchNearestSite(getCoords(firstIn), 500);
      const endSite   = matchNearestSite(getCoords(lastOut), 500);

      const startMins = startSite?.travelTimeFromHQMinutes ?? "";
      const endMins   = endSite?.travelTimeFromHQMinutes ?? "";

      const travelHours = minsToHours(startMins) + minsToHours(endMins);

      if(travelHours > 0){
        // Add travel into totals, and apply same Std/OT rule (consume remainingStd first)
        const sTravel = Math.min(travelHours, Math.max(remainingStd,0));
        const oTravel = Math.max(travelHours - sTravel, 0);
        remainingStd -= sTravel;

        total += travelHours;
        std   += sTravel;
        ot    += oTravel;

        const startLabel = startSite ? `${startSite.siteName} (${startMins} min)` : `Unknown`;
        const endLabel   = endSite   ? `${endSite.siteName} (${endMins} min)` : `Unknown`;

        group.innerHTML+=`
          <div class="session-card">
            <div class="session-time">üöó Travel Time (HQ)</div>
            <div class="session-hours">
              <span>Total ${travelHours.toFixed(2)}</span>
              <span>Std ${sTravel.toFixed(2)}</span>
              <span>OT ${oTravel.toFixed(2)}</span>
            </div>
            <div class="location">Start: ${startLabel}</div>
            <div class="location">Finish: ${endLabel}</div>
          </div>`;
      }
    }
    /* ===================== END NEW TRAVEL LOGIC ===================== */

    sessionsEl.appendChild(group);
  });

  sumStd.textContent=std.toFixed(2)+" h";
  sumOT.textContent=ot.toFixed(2)+" h";
  sumTotal.textContent=total.toFixed(2)+" h";
  statusEl.textContent="";
}

document.getElementById("prevWeek").onclick=()=>{currentWeek.setDate(currentWeek.getDate()-7);loadWeek();};
document.getElementById("nextWeek").onclick=()=>{currentWeek.setDate(currentWeek.getDate()+7);loadWeek();};

/* ===== REAL PDF DOWNLOAD ===== */
document.getElementById("exportBtn").onclick=()=>{
  const wc = friendlyDate(currentWeek).replace(/\s+/g,"_");
  const filename = `Timesheet_${user||"Engineer"}_${wc}.pdf`;

  html2pdf()
    .set({
      margin:10,
      filename,
      image:{type:"jpeg",quality:0.98},
      html2canvas:{scale:2,useCORS:true},
      jsPDF:{unit:"mm",format:"a4",orientation:"portrait"}
    })
    .from(document.getElementById("pdfRoot"))
    .save();
};

loadWeek();
</script>

</body>
</html>
